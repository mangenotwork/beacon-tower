# beacon-tower
基于传输层TCP/UDP设计和封装的应用层网络传输协议，目的是为高效开发CS架构项目的数据传输功能提供支持。

## 基于UDP的网络传输协议

### 设计:

数据包:
```
Packet 包设计
______________________________________________________________________
|            |              |             |                           |
| 指令(1字节) |  name(7字节)  | 签名(7字节)  |  data(建议小于533字节)...  |
|____________|______________|_____________|___________________________|

指令: 区分是什么数据 Connect,Put,Reply,Heartbeat,Notice,Get
name: 主要场景s端指定广播，name对应多个ip(节点)
签名: 用于确保数据安全，签名会更具心跳进行动态签发
data: 传输的数据，不支持分包，建议小于533字节，可以在业务中设计分次传输

封包 : 装载数据 -> 压缩 -> 加密  
解包 : 解密 -> 解压 -> 匹配指令 -> 验证签名

```

是如何提升安全性?
1. 采用连接认证机制  
2. IP黑白名单
3. 动态签名机制   
4. 数据加解密 

是如何提升可靠性?
- 心跳与时间轮机制
- 数据传输确认机制
- 数据积压机制
- 数据重传机制

其他?
- 数据压缩


限制: 
数据包应小而独立，大数据包应在业务层进行拆分

### 基础
#### S 端有 Notice(通知), Get(获取) 两种通讯方法

Notice
1. 一对多发送通知
2. 支持重传
3. 指定节点发送通知

Get
1. 获取C端数据
2. 超时报错

#### C 端有 Put(发送), Get(获取) 两种通讯方法

Put
1. 发送数据包
2. 积压模式: 每个数据包都会被积压，只有当s端确认接收后清除，当心跳包确认后触发积压数据重传
3. 积压数据持久化: 积压数据包到达一定量被持久化到磁盘，重传时积压数据小于指定值读取持久化数据一半的数据量
4. C端收到信号量 SIGTERM, SIGINT, SIGKILL, SIGHUP, SIGQUIT 当前积压数据包全部持久化

Get
1. 获取C端数据
2. 超时报错


### 安全

1. 使用 DES ECB 对数据包加解密，保障数据被抓包并非明文
2. 连接Code用于确保两端下发签名的识别
3. 每次收到心跳包重新颁发签名
4. 除连接包和心跳包都会确认签名

## 基于TCP的网络传输协议

TODO...

